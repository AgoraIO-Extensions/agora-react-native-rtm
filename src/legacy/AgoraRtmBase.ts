/// Generated by terra, DO NOT MODIFY BY HAND.

/**
 * Rtm link state.
 */
export enum RtmLinkState {
  /**
   * The initial state.
   */
  idle = 0,
  /**
   * The SDK is connecting to the server.
   */
  connecting = 1,
  /**
   * The SDK has connected to the server.
   */
  connected = 2,
  /**
   * The SDK is disconnected from the server.
   */
  disconnected = 3,
  /**
   * The SDK link is suspended.
   */
  suspended = 4,
  /**
   * The SDK is failed to connect to the server.
   */
  failed = 5,
}

/**
 * Rtm link operation.
 */
export enum RtmLinkOperation {
  /**
   * Login.
   */
  login = 0,
  /**
   * Logout.
   */
  logout = 1,
  /**
   * Join
   */
  join = 2,
  /**
   * Leave.
   */
  leave = 3,
  /**
   * Server reject
   */
  serverReject = 4,
  /**
   * Auto reconnect
   */
  autoReconnect = 5,
  /**
   * Reconnected
   */
  reconnected = 6,
  /**
   * Heartbeat lost
   */
  heartbeatLost = 7,
  /**
   * Server timeout
   */
  serverTimeout = 8,
  /**
   * Network change
   */
  networkChange = 9,
}

/**
 * Rtm service type.
 */
export enum RtmServiceType {
  /**
   * The type of rtm service not specified.
   */
  none = 0,
  /**
   * The basic functionality of rtm service.
   */
  message = 1,
  /**
   * The advanced functionality of rtm service.
   */
  stream = 2,
}

/**
 * Rtm link state change reason.
 */
export enum RtmLinkStateChangeReason {
  /**
   * Unknown reason.
   */
  unknown = 0,
  /**
   * Login.
   */
  login = 1,
  /**
   * Login success.
   */
  loginSuccess = 2,
  /**
   * Login timeout.
   */
  loginTimeout = 3,
  /**
   * Login not authorized.
   */
  loginNotAuthorized = 4,
  /**
   * Login rejected.
   */
  loginRejected = 5,
  /**
   * Re-login.
   */
  relogin = 6,
  /**
   * Logout.
   */
  logout = 7,
  /**
   * Auto reconnect.
   */
  autoReconnect = 8,
  /**
   * Reconnect timeout.
   */
  reconnectTimeout = 9,
  /**
   * Reconnect success.
   */
  reconnectSuccess = 10,
  /**
   * Join.
   */
  join = 11,
  /**
   * Join success.
   */
  joinSuccess = 12,
  /**
   * Join failed.
   */
  joinFailed = 13,
  /**
   * Rejoin.
   */
  rejoin = 14,
  /**
   * Leave.
   */
  leave = 15,
  /**
   * Invalid token.
   */
  invalidToken = 16,
  /**
   * Token expired.
   */
  tokenExpired = 17,
  /**
   * Inconsistent app ID.
   */
  inconsistentAppId = 18,
  /**
   * Invalid channel name.
   */
  invalidChannelName = 19,
  /**
   * Invalid user ID.
   */
  invalidUserId = 20,
  /**
   * Not initialized.
   */
  notInitialized = 21,
  /**
   * Rtm service not connected.
   */
  rtmServiceNotConnected = 22,
  /**
   * Channel instance exceed limitation.
   */
  channelInstanceExceedLimitation = 23,
  /**
   * Operation rate exceed limitation.
   */
  operationRateExceedLimitation = 24,
  /**
   * Channel in error state.
   */
  channelInErrorState = 25,
  /**
   * Presence not connected.
   */
  presenceNotConnected = 26,
  /**
   * Same UID login.
   */
  sameUidLogin = 27,
  /**
   * Kicked out by server.
   */
  kickedOutByServer = 28,
  /**
   * Keep alive timeout.
   */
  keepAliveTimeout = 29,
  /**
   * Connection error.
   */
  connectionError = 30,
  /**
   * Presence not ready.
   */
  presenceNotReady = 31,
  /**
   * Network change.
   */
  networkChange = 32,
  /**
   * Service not supported.
   */
  serviceNotSupported = 33,
  /**
   * Stream channel not available.
   */
  streamChannelNotAvailable = 34,
  /**
   * storage not available.
   */
  storageNotAvailable = 35,
  /**
   * Lock not available.
   */
  lockNotAvailable = 36,
  /**
   * Login too frequent.
   */
  loginTooFrequent = 37,
}

/**
 * Rtm protocol type for underlying connection.
 */
export enum RtmProtocolType {
  /**
   * TCP and UDP (default).
   */
  tcpUdp = 0,
  /**
   * Use TCP only.
   */
  tcpOnly = 1,
}

/**
 * IP areas.
 */
export enum RtmAreaCode {
  /**
   * Mainland China.
   */
  cn = 1,
  /**
   * North America.
   */
  na = 2,
  /**
   * Europe.
   */
  eu = 4,
  /**
   * Asia, excluding Mainland China.
   */
  as = 8,
  /**
   * Japan.
   */
  jp = 16,
  /**
   * India.
   */
  in = 32,
  /**
   * (Default) Global.
   */
  glob = 4294967295,
}

/**
 * The log level for rtm sdk.
 */
export enum RtmLogLevel {
  /**
   * 0x0000: No logging.
   */
  none = 0,
  /**
   * 0x0001: Informational messages.
   */
  info = 1,
  /**
   * 0x0002: Warnings.
   */
  warn = 2,
  /**
   * 0x0004: Errors.
   */
  error = 4,
  /**
   * 0x0008: Critical errors that may lead to program termination.
   */
  fatal = 8,
}

/**
 * The encryption mode.
 */
export enum RtmEncryptionMode {
  /**
   * Disable message encryption.
   */
  none = 0,
  /**
   * 128-bit AES encryption, GCM mode.
   */
  aes128Gcm = 1,
  /**
   * 256-bit AES encryption, GCM mode.
   */
  aes256Gcm = 2,
}

/**
 * The error codes of rtm client.
 */
export enum ErrorCode {
  /**
   * 0: No error occurs.
   */
  ok = 0,
  /**
   * -10001 ~ -11000 : reserved for generic error.
   * -10001: The SDK is not initialized.
   */
  notInitialized = -10001,
  /**
   * -10002: The user didn't login the RTM system.
   */
  notLogin = -10002,
  /**
   * -10003: The app ID is invalid.
   */
  invalidAppId = -10003,
  /**
   * -10004: The event handler is invalid.
   */
  invalidEventHandler = -10004,
  /**
   * -10005: The token is invalid.
   */
  invalidToken = -10005,
  /**
   * -10006: The user ID is invalid.
   */
  invalidUserId = -10006,
  /**
   * -10007: The service is not initialized.
   */
  initServiceFailed = -10007,
  /**
   * -10008: The channel name is invalid.
   */
  invalidChannelName = -10008,
  /**
   * -10009: The token has expired.
   */
  tokenExpired = -10009,
  /**
   * -10010: There is no server resources now.
   */
  loginNoServerResources = -10010,
  /**
   * -10011: The login timeout.
   */
  loginTimeout = -10011,
  /**
   * -10012: The login is rejected by server.
   */
  loginRejected = -10012,
  /**
   * -10013: The login is aborted due to unrecoverable error.
   */
  loginAborted = -10013,
  /**
   * -10014: The parameter is invalid.
   */
  invalidParameter = -10014,
  /**
   * -10015: The login is not authorized. Happens user login the RTM system without granted from console.
   */
  loginNotAuthorized = -10015,
  /**
   * -10016: Try to login or join with inconsistent app ID.
   */
  inconsistentAppid = -10016,
  /**
   * -10017: Already call same request.
   */
  duplicateOperation = -10017,
  /**
   * -10018: Already call destroy or release, this instance is forbidden to call any api, please create new instance.
   */
  instanceAlreadyReleased = -10018,
  /**
   * -10019: The channel type is invalid.
   */
  invalidChannelType = -10019,
  /**
   * -10020: The encryption parameter is invalid.
   */
  invalidEncryptionParameter = -10020,
  /**
   * -10021: The operation is too frequent.
   */
  operationRateExceedLimitation = -10021,
  /**
   * -10022: The service is not configured in private config mode.
   */
  serviceNotSupported = -10022,
  /**
   * -10023: This login operation stopped by a new login operation or logout operation.
   */
  loginCanceled = -10023,
  /**
   * -10024: The private config is invalid, set private config should both set serviceType and accessPointHosts.
   */
  invalidPrivateConfig = -10024,
  /**
   * -10025: Perform operation failed due to RTM service is not connected.
   */
  notConnected = -10025,
  /**
   * -10026: Renew token timeout.
   */
  renewTokenTimeout = -10026,
  /**
   * -11001 ~ -12000 : reserved for channel error.
   * -11001: The user has not joined the channel.
   */
  channelNotJoined = -11001,
  /**
   * -11002: The user has not subscribed the channel.
   */
  channelNotSubscribed = -11002,
  /**
   * -11003: The topic member count exceeds the limit.
   */
  channelExceedTopicUserLimitation = -11003,
  /**
   * -11004: The channel is reused in RTC.
   */
  channelInReuse = -11004,
  /**
   * -11005: The channel instance count exceeds the limit.
   */
  channelInstanceExceedLimitation = -11005,
  /**
   * -11006: The channel is in error state.
   */
  channelInErrorState = -11006,
  /**
   * -11007: The channel join failed.
   */
  channelJoinFailed = -11007,
  /**
   * -11008: The topic name is invalid.
   */
  channelInvalidTopicName = -11008,
  /**
   * -11009: The message is invalid.
   */
  channelInvalidMessage = -11009,
  /**
   * -11010: The message length exceeds the limit.
   */
  channelMessageLengthExceedLimitation = -11010,
  /**
   * -11011: The user list is invalid.
   */
  channelInvalidUserList = -11011,
  /**
   * -11012: The stream channel is not available.
   */
  channelNotAvailable = -11012,
  /**
   * -11013: The topic is not subscribed.
   */
  channelTopicNotSubscribed = -11013,
  /**
   * -11014: The topic count exceeds the limit.
   */
  channelExceedTopicLimitation = -11014,
  /**
   * -11015: Join topic failed.
   */
  channelJoinTopicFailed = -11015,
  /**
   * -11016: The topic is not joined.
   */
  channelTopicNotJoined = -11016,
  /**
   * -11017: The topic does not exist.
   */
  channelTopicNotExist = -11017,
  /**
   * -11018: The topic meta is invalid.
   */
  channelInvalidTopicMeta = -11018,
  /**
   * -11019: Subscribe channel timeout.
   */
  channelSubscribeTimeout = -11019,
  /**
   * -11020: Subscribe channel too frequent.
   */
  channelSubscribeTooFrequent = -11020,
  /**
   * -11021: Subscribe channel failed.
   */
  channelSubscribeFailed = -11021,
  /**
   * -11022: Unsubscribe channel failed.
   */
  channelUnsubscribeFailed = -11022,
  /**
   * -11023: Encrypt message failed.
   */
  channelEncryptMessageFailed = -11023,
  /**
   * -11024: Publish message failed.
   */
  channelPublishMessageFailed = -11024,
  /**
   * -11025: Publish message too frequent.
   */
  channelPublishMessageTooFrequent = -11025,
  /**
   * -11026: Publish message timeout.
   */
  channelPublishMessageTimeout = -11026,
  /**
   * -11027: The connection state is invalid.
   */
  channelNotConnected = -11027,
  /**
   * -11028: Leave channel failed.
   */
  channelLeaveFailed = -11028,
  /**
   * -11029: The custom type length exceeds the limit.
   */
  channelCustomTypeLengthOverflow = -11029,
  /**
   * -11030: The custom type is invalid.
   */
  channelInvalidCustomType = -11030,
  /**
   * -11031: unsupported message type (in MacOS/iOS platform，message only support NSString and NSData)
   */
  channelUnsupportedMessageType = -11031,
  /**
   * -11032: The channel presence is not ready.
   */
  channelPresenceNotReady = -11032,
  /**
   * -11033: The destination user of publish message is offline.
   */
  channelReceiverOffline = -11033,
  /**
   * -11034: The channel join operation is canceled.
   */
  channelJoinCanceled = -11034,
  /**
   * -11035: The message receiver is offline but the message store in history succeeded.
   */
  channelReceiverOfflineButStoreSucceeded = -11035,
  /**
   * -11036: The message receiver is offline and the message store in history failed.
   */
  channelReceiverOfflineAndStoreFailed = -11036,
  /**
   * -11037: The message delivered successfully but store in history failed.
   */
  channelMessageDeliveredButStoreFailed = -11037,
  /**
   * -12001 ~ -13000 : reserved for storage error.
   * -12001: The storage operation failed.
   */
  storageOperationFailed = -12001,
  /**
   * -12002: The metadata item count exceeds the limit.
   */
  storageMetadataItemExceedLimitation = -12002,
  /**
   * -12003: The metadata item is invalid.
   */
  storageInvalidMetadataItem = -12003,
  /**
   * -12004: The argument in storage operation is invalid.
   */
  storageInvalidArgument = -12004,
  /**
   * -12005: The revision in storage operation is invalid.
   */
  storageInvalidRevision = -12005,
  /**
   * -12006: The metadata length exceeds the limit.
   */
  storageMetadataLengthOverflow = -12006,
  /**
   * -12007: The lock name in storage operation is invalid.
   */
  storageInvalidLockName = -12007,
  /**
   * -12008: The lock in storage operation is not acquired.
   */
  storageLockNotAcquired = -12008,
  /**
   * -12009: The metadata key is invalid.
   */
  storageInvalidKey = -12009,
  /**
   * -12010: The metadata value is invalid.
   */
  storageInvalidValue = -12010,
  /**
   * -12011: The metadata key length exceeds the limit.
   */
  storageKeyLengthOverflow = -12011,
  /**
   * -12012: The metadata value length exceeds the limit.
   */
  storageValueLengthOverflow = -12012,
  /**
   * -12013: The metadata key already exists.
   */
  storageDuplicateKey = -12013,
  /**
   * -12014: The revision in storage operation is outdated or the key does not exist.
   */
  storageOutdatedRevision = -12014,
  /**
   * -12015: The storage operation performed without subscribing.
   */
  storageNotSubscribe = -12015,
  /**
   * -12016: The metadata item is invalid.
   */
  storageInvalidMetadataInstance = -12016,
  /**
   * -12017: The user count exceeds the limit when try to subscribe.
   */
  storageSubscribeUserExceedLimitation = -12017,
  /**
   * -12018: The storage operation timeout.
   */
  storageOperationTimeout = -12018,
  /**
   * -12019: The storage service not available.
   */
  storageNotAvailable = -12019,
  /**
   * -13001 ~ -14000 : reserved for presence error.
   * -13001: The user is not connected.
   */
  presenceNotConnected = -13001,
  /**
   * -13002: The presence is not writable.
   */
  presenceNotWritable = -13002,
  /**
   * -13003: The argument in presence operation is invalid.
   */
  presenceInvalidArgument = -13003,
  /**
   * -13004: The cached presence state count exceeds the limit.
   */
  presenceCachedTooManyStates = -13004,
  /**
   * -13005: The state count exceeds the limit.
   */
  presenceStateCountOverflow = -13005,
  /**
   * -13006: The state key is invalid.
   */
  presenceInvalidStateKey = -13006,
  /**
   * -13007: The state value is invalid.
   */
  presenceInvalidStateValue = -13007,
  /**
   * -13008: The state key length exceeds the limit.
   */
  presenceStateKeySizeOverflow = -13008,
  /**
   * -13009: The state value length exceeds the limit.
   */
  presenceStateValueSizeOverflow = -13009,
  /**
   * -13010: The state key already exists.
   */
  presenceStateDuplicateKey = -13010,
  /**
   * -13011: The user is not exist.
   */
  presenceUserNotExist = -13011,
  /**
   * -13012: The presence operation timeout.
   */
  presenceOperationTimeout = -13012,
  /**
   * -13013: The presence operation failed.
   */
  presenceOperationFailed = -13013,
  /**
   * -14001 ~ -15000 : reserved for lock error.
   * -14001: The lock operation failed.
   */
  lockOperationFailed = -14001,
  /**
   * -14002: The lock operation timeout.
   */
  lockOperationTimeout = -14002,
  /**
   * -14003: The lock operation is performing.
   */
  lockOperationPerforming = -14003,
  /**
   * -14004: The lock already exists.
   */
  lockAlreadyExist = -14004,
  /**
   * -14005: The lock name is invalid.
   */
  lockInvalidName = -14005,
  /**
   * -14006: The lock is not acquired.
   */
  lockNotAcquired = -14006,
  /**
   * -14007: Acquire lock failed.
   */
  lockAcquireFailed = -14007,
  /**
   * -14008: The lock is not exist.
   */
  lockNotExist = -14008,
  /**
   * -14009: The lock service is not available.
   */
  lockNotAvailable = -14009,
  /**
   * -15001 ~ -16000 : reserved for history error.
   * -15001: The history operation failed.
   */
  historyOperationFailed = -15001,
  /**
   * -15002: The timestamp is invalid.
   */
  historyInvalidTimestamp = -15002,
  /**
   * -15003: The history operation timeout.
   */
  historyOperationTimeout = -15003,
  /**
   * -15004: The history operation is not permitted.
   */
  historyOperationNotPermitted = -15004,
  /**
   * -15005: The history service not available.
   */
  historyNotAvailable = -15005,
}

/**
 * Connection states between rtm sdk and agora server.
 */
export enum RtmConnectionState {
  /**
   * 1: The SDK is disconnected with server.
   */
  disconnected = 1,
  /**
   * 2: The SDK is connecting to the server.
   */
  connecting = 2,
  /**
   * 3: The SDK is connected to the server and has joined a channel. You can now publish or subscribe to
   * a track in the channel.
   */
  connected = 3,
  /**
   * 4: The SDK keeps rejoining the channel after being disconnected from the channel, probably because of
   * network issues.
   */
  reconnecting = 4,
  /**
   * 5: The SDK fails to connect to the server or join the channel.
   */
  failed = 5,
}

/**
 * Reasons for connection state change.
 */
export enum RtmConnectionChangeReason {
  /**
   * 0: The SDK is connecting to the server.
   */
  rtmConnectionChangedConnecting = 0,
  /**
   * 1: The SDK has joined the channel successfully.
   */
  rtmConnectionChangedJoinSuccess = 1,
  /**
   * 2: The connection between the SDK and the server is interrupted.
   */
  rtmConnectionChangedInterrupted = 2,
  /**
   * 3: The connection between the SDK and the server is banned by the server.
   */
  rtmConnectionChangedBannedByServer = 3,
  /**
   * 4: The SDK fails to join the channel for more than 20 minutes and stops reconnecting to the channel.
   */
  rtmConnectionChangedJoinFailed = 4,
  /**
   * 5: The SDK has left the channel.
   */
  rtmConnectionChangedLeaveChannel = 5,
  /**
   * 6: The connection fails because the App ID is not valid.
   */
  rtmConnectionChangedInvalidAppId = 6,
  /**
   * 7: The connection fails because the channel name is not valid.
   */
  rtmConnectionChangedInvalidChannelName = 7,
  /**
   * 8: The connection fails because the token is not valid.
   */
  rtmConnectionChangedInvalidToken = 8,
  /**
   * 9: The connection fails because the token has expired.
   */
  rtmConnectionChangedTokenExpired = 9,
  /**
   * 10: The connection is rejected by the server.
   */
  rtmConnectionChangedRejectedByServer = 10,
  /**
   * 11: The connection changes to reconnecting because the SDK has set a proxy server.
   */
  rtmConnectionChangedSettingProxyServer = 11,
  /**
   * 12: When the connection state changes because the app has renewed the token.
   */
  rtmConnectionChangedRenewToken = 12,
  /**
   * 13: The IP Address of the app has changed. A change in the network type or IP/Port changes the IP
   * address of the app.
   */
  rtmConnectionChangedClientIpAddressChanged = 13,
  /**
   * 14: A timeout occurs for the keep-alive of the connection between the SDK and the server.
   */
  rtmConnectionChangedKeepAliveTimeout = 14,
  /**
   * 15: The SDK has rejoined the channel successfully.
   */
  rtmConnectionChangedRejoinSuccess = 15,
  /**
   * 16: The connection between the SDK and the server is lost.
   */
  rtmConnectionChangedLost = 16,
  /**
   * 17: The change of connection state is caused by echo test.
   */
  rtmConnectionChangedEchoTest = 17,
  /**
   * 18: The local IP Address is changed by user.
   */
  rtmConnectionChangedClientIpAddressChangedByUser = 18,
  /**
   * 19: The connection is failed due to join the same channel on another device with the same uid.
   */
  rtmConnectionChangedSameUidLogin = 19,
  /**
   * 20: The connection is failed due to too many broadcasters in the channel.
   */
  rtmConnectionChangedTooManyBroadcasters = 20,
  /**
   * 21: The connection is failed due to license validation failure.
   */
  rtmConnectionChangedLicenseValidationFailure = 21,
  /**
   * 22: The connection is failed due to certification verify failure.
   */
  rtmConnectionChangedCertificationVerifyFailure = 22,
  /**
   * 23: The connection is failed due to user vid not support stream channel.
   */
  rtmConnectionChangedStreamChannelNotAvailable = 23,
  /**
   * 24: The connection is failed due to token and appid inconsistent.
   */
  rtmConnectionChangedInconsistentAppid = 24,
  /**
   * 10001: The connection of rtm edge service has been successfully established.
   */
  rtmConnectionChangedLoginSuccess = 10001,
  /**
   * 10002: User log out Agora RTM system.
   */
  rtmConnectionChangedLogout = 10002,
  /**
   * 10003: User log out Agora RTM system.
   */
  rtmConnectionChangedPresenceNotReady = 10003,
}

/**
 * RTM channel type.
 */
export enum RtmChannelType {
  /**
   * 0: Unknown channel type.
   */
  none = 0,
  /**
   * 1: Message channel.
   */
  message = 1,
  /**
   * 2: Stream channel.
   */
  stream = 2,
  /**
   * 3: User.
   */
  user = 3,
}

/**
 * @brief Message type when user publish message to channel or topic
 */
export enum RtmMessageType {
  /**
   * 0: The binary message.
   */
  binary = 0,
  /**
   * 1: The ascii message.
   */
  string = 1,
}

/**
 * @brief Storage type indicate the storage event was triggered by user or channel
 */
export enum RtmStorageType {
  /**
   * 0: Unknown type.
   */
  none = 0,
  /**
   * 1: The user storage event.
   */
  user = 1,
  /**
   * 2: The channel storage event.
   */
  channel = 2,
}

/**
 * The storage event type, indicate storage operation
 */
export enum RtmStorageEventType {
  /**
   * 0: Unknown event type.
   */
  none = 0,
  /**
   * 1: Triggered when user subscribe user metadata state or join channel with options.withMetadata = true
   */
  snapshot = 1,
  /**
   * 2: Triggered when a remote user set metadata
   */
  set = 2,
  /**
   * 3: Triggered when a remote user update metadata
   */
  update = 3,
  /**
   * 4: Triggered when a remote user remove metadata
   */
  remove = 4,
}

/**
 * The lock event type, indicate lock operation
 */
export enum RtmLockEventType {
  /**
   * 0: Unknown event type
   */
  none = 0,
  /**
   * 1: Triggered when user subscribe lock state
   */
  snapshot = 1,
  /**
   * 2: Triggered when a remote user set lock
   */
  lockSet = 2,
  /**
   * 3: Triggered when a remote user remove lock
   */
  lockRemoved = 3,
  /**
   * 4: Triggered when a remote user acquired lock
   */
  lockAcquired = 4,
  /**
   * 5: Triggered when a remote user released lock
   */
  lockReleased = 5,
  /**
   * 6: Triggered when user reconnect to rtm service,
   * detect the lock has been acquired and released by others.
   */
  lockExpired = 6,
}

/**
 * The proxy type
 */
export enum RtmProxyType {
  /**
   * 0: Link without proxy
   */
  none = 0,
  /**
   * 1: Link with http proxy
   */
  http = 1,
  /**
   * 2: Link with tcp cloud proxy
   */
  cloudTcp = 2,
}

/**
 * @brief Topic event type
 */
export enum RtmTopicEventType {
  /**
   * 0: Unknown event type
   */
  none = 0,
  /**
   * 1: The topic snapshot of this channel
   */
  snapshot = 1,
  /**
   * 2: Triggered when remote user join a topic
   */
  remoteJoinTopic = 2,
  /**
   * 3: Triggered when remote user leave a topic
   */
  remoteLeaveTopic = 3,
}

/**
 * @brief Presence event type
 */
export enum RtmPresenceEventType {
  /**
   * 0: Unknown event type
   */
  none = 0,
  /**
   * 1: The presence snapshot of this channel
   */
  snapshot = 1,
  /**
   * 2: The presence event triggered in interval mode
   */
  interval = 2,
  /**
   * 3: Triggered when remote user join channel
   */
  remoteJoinChannel = 3,
  /**
   * 4: Triggered when remote user leave channel
   */
  remoteLeaveChannel = 4,
  /**
   * 5: Triggered when remote user's connection timeout
   */
  remoteTimeout = 5,
  /**
   * 6: Triggered when user changed state
   */
  remoteStateChanged = 6,
  /**
   * 7: Triggered when user joined channel without presence service
   */
  errorOutOfService = 7,
}

/**
 * Definition of LogConfiguration
 */
export class RtmLogConfig {
  /**
   * The log file path, default is NULL for default log path
   */
  filePath?: string;
  /**
   * The log file size, KB , set 1024KB to use default log size
   */
  fileSizeInKB?: number;
  /**
   *  The log level, set LOG_LEVEL_INFO to use default log level
   */
  level?: RtmLogLevel = RtmLogLevel.info;
  constructor(
    props?: Partial<{
      filePath?: string;
      fileSizeInKB?: number;
      level?: RtmLogLevel;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * User list.
 */
export class UserList {
  /**
   * The list of users.
   */
  users?: string[];
  /**
   * The number of users.
   */
  userCount?: number = 0;
  constructor(
    props?: Partial<{
      users?: string[];
      userCount?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief Topic publisher information
 */
export class PublisherInfo {
  /**
   * The publisher user ID
   */
  publisherUserId?: string;
  /**
   * The metadata of the publisher
   */
  publisherMeta?: string;
  constructor(
    props?: Partial<{
      publisherUserId?: string;
      publisherMeta?: string;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief Topic information
 */
export class TopicInfo {
  /**
   * The name of the topic
   */
  topic?: string;
  /**
   * The publisher array
   */
  publishers?: PublisherInfo[];
  /**
   * The count of publisher in current topic
   */
  publisherCount?: number = 0;
  constructor(
    props?: Partial<{
      topic?: string;
      publishers?: PublisherInfo[];
      publisherCount?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief User state property
 */
export class StateItem {
  /**
   * The key of the state item.
   */
  key?: string;
  /**
   * The value of the state item.
   */
  value?: string;
  constructor(
    props?: Partial<{
      key?: string;
      value?: string;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 *  The information of a Lock.
 */
export class LockDetail {
  /**
   * The name of the lock.
   */
  lockName?: string;
  /**
   * The owner of the lock. Only valid when user getLocks or receive LockEvent with RTM_LOCK_EVENT_TYPE_SNAPSHOT
   */
  owner?: string;
  /**
   * The ttl of the lock.
   */
  ttl?: number;
  constructor(
    props?: Partial<{
      lockName?: string;
      owner?: string;
      ttl?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 *  The states of user.
 */
export class UserState {
  /**
   * The user id.
   */
  userId?: string;
  /**
   * The user states.
   */
  states?: StateItem[];
  /**
   * The count of user states.
   */
  statesCount?: number = 0;
  constructor(
    props?: Partial<{
      userId?: string;
      states?: StateItem[];
      statesCount?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 *  The subscribe option.
 */
export class SubscribeOptions {
  /**
   * Whether to subscribe channel with message
   */
  withMessage?: boolean = true;
  /**
   * Whether to subscribe channel with metadata
   */
  withMetadata?: boolean = false;
  /**
   * Whether to subscribe channel with user presence
   */
  withPresence?: boolean = true;
  /**
   * Whether to subscribe channel with lock
   */
  withLock?: boolean = false;
  /**
   * Whether to subscribe channel in quiet mode
   * Quiet mode means remote user will not receive any notification when we subscribe or
   * unsubscribe or change our presence state
   */
  beQuiet?: boolean = false;
  constructor(
    props?: Partial<{
      withMessage?: boolean;
      withMetadata?: boolean;
      withPresence?: boolean;
      withLock?: boolean;
      beQuiet?: boolean;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 *  The channel information.
 */
export class ChannelInfo {
  /**
   * The channel which the message was published
   */
  channelName?: string;
  /**
   * Which channel type, RtmChannelType_STREAM or message
   */
  channelType?: RtmChannelType;
  constructor(
    props?: Partial<{
      channelName?: string;
      channelType?: RtmChannelType;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 *  The option to query user presence.
 */
export class PresenceOptions {
  /**
   * Whether to display user id in query result
   */
  includeUserId?: boolean = true;
  /**
   * Whether to display user state in query result
   */
  includeState?: boolean = false;
  /**
   * The paging object used for pagination.
   */
  page?: string;
  constructor(
    props?: Partial<{
      includeUserId?: boolean;
      includeState?: boolean;
      page?: string;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief Publish message option
 */
export class PublishOptions {
  /**
   * The channel type.
   */
  channelType?: RtmChannelType = RtmChannelType.message;
  /**
   * The message type.
   */
  messageType?: RtmMessageType = RtmMessageType.binary;
  /**
   * The custom type of the message, up to 32 bytes for customize
   */
  customType?: string;
  /**
   * Whether to store in history, true to enable
   */
  storeInHistory?: boolean = false;
  constructor(
    props?: Partial<{
      channelType?: RtmChannelType;
      messageType?: RtmMessageType;
      customType?: string;
      storeInHistory?: boolean;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief topic message option
 */
export class TopicMessageOptions {
  /**
   * The message type.
   */
  messageType?: RtmMessageType = RtmMessageType.binary;
  /**
   * The time to calibrate data with media,
   * only valid when user join topic with syncWithMedia in stream channel
   */
  sendTs?: number;
  /**
   * The custom type of the message, up to 32 bytes for customize
   */
  customType?: string;
  constructor(
    props?: Partial<{
      messageType?: RtmMessageType;
      sendTs?: number;
      customType?: string;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 *  The option to query user presence.
 */
export class GetOnlineUsersOptions {
  /**
   * Whether to display user id in query result
   */
  includeUserId?: boolean = true;
  /**
   * Whether to display user state in query result
   */
  includeState?: boolean = false;
  /**
   * The paging object used for pagination.
   */
  page?: string;
  constructor(
    props?: Partial<{
      includeUserId?: boolean;
      includeState?: boolean;
      page?: string;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief Proxy configuration
 */
export class RtmProxyConfig {
  /**
   * The Proxy type.
   */
  proxyType?: RtmProxyType = RtmProxyType.none;
  /**
   * The Proxy server address.
   */
  server?: string;
  /**
   * The Proxy server port.
   */
  port?: number;
  /**
   * The Proxy user account.
   */
  account?: string;
  /**
   * The Proxy password.
   */
  password?: string;
  constructor(
    props?: Partial<{
      proxyType?: RtmProxyType;
      server?: string;
      port?: number;
      account?: string;
      password?: string;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief encryption configuration
 */
export class RtmEncryptionConfig {
  /**
   * The encryption mode.
   */
  encryptionMode?: RtmEncryptionMode = RtmEncryptionMode.none;
  /**
   * The encryption key in the string format.
   */
  encryptionKey?: string;
  /**
   * The encryption salt.
   */
  encryptionSalt?: number[];
  constructor(
    props?: Partial<{
      encryptionMode?: RtmEncryptionMode;
      encryptionKey?: string;
      encryptionSalt?: number[];
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief Private configuration
 */
export class RtmPrivateConfig {
  /**
   * Rtm service type.
   */
  serviceType?: RtmServiceType = RtmServiceType.none;
  /**
   * Local access point hosts list.
   */
  accessPointHosts?: string[];
  /**
   * The count of access point hosts list.
   */
  accessPointHostsCount?: number = 0;
  constructor(
    props?: Partial<{
      serviceType?: RtmServiceType;
      accessPointHosts?: string[];
      accessPointHostsCount?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief The option to query history message.
 */
export class GetHistoryMessagesOptions {
  /**
   * The maximum count of messages to get.
   */
  messageCount?: number;
  /**
   * The start timestamp of this query range.
   */
  start?: number;
  /**
   * The end timestamp of this query range.
   */
  end?: number;
  constructor(
    props?: Partial<{
      messageCount?: number;
      start?: number;
      end?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}

/**
 * @brief The details of history message
 */
export class HistoryMessage {
  /**
   * Message type
   */
  messageType?: RtmMessageType = RtmMessageType.binary;
  /**
   * The publisher
   */
  publisher?: string;
  /**
   * The payload
   */
  message?: string;
  /**
   * The payload length
   */
  messageLength?: number = 0;
  /**
   * The custom type of the message
   */
  customType?: string;
  /**
   * Timestamp of the message received by rtm server
   */
  timestamp?: number;
  constructor(
    props?: Partial<{
      messageType?: RtmMessageType;
      publisher?: string;
      message?: string;
      messageLength?: number;
      customType?: string;
      timestamp?: number;
    }>
  ) {
    Object.assign(this, props);
  }
}
